# JWT 学習用

JWT(json web tokens)に関しての学習用です。概要などの説明となります。  
サンプルに用意しているプログラムに関してセキュリティリスクは考慮しておりません。

実際に JWT を利用する際にはセキュリティ等も考慮してご利用ください。

## セットアップ

```
docker-compose up -d
```

---

## 最初に

こちらの記載している情報は若干意訳も含めてた内容となります。またセキュリティリスクにかんしては、詳しく触れない為必ず下記の記事やサイトもあわせて閲覧してください。

> https://techblog.yahoo.co.jp/advent-calendar-2017/jwt/

## 概要

JWT(`json web tokens`)とは、最近ではデファクトスタンダードなアクセストークンとして利用されています。
クラウド（Google や AWS など）から API を経由してデータを取得する事が多くなりました。

それに伴いアクセストークンとして使われる事となったのは、JWT の特徴である`ステートレス`であることが大きいです。

`ステートレス`とは、文字通りサーバ側で状態は保存していません。

いままでも認証などを使ったシステムもありましたが、`session`や`cookie`などを利用して認証情報を管理していました。

ブラウザを介して接続することが前提な Web アプリケーションでそれで構いませんが、其れ意外の手段の場合では認証（固有情報）の情報を保持することができませんし、色々なシーンで利用する際には利用する手法として JWT が使われるようになっていきました。

さて、セッションなどであれば API 側で固有情報を元にデータを用意する事はできますが JWT ではどのように固有情報を管理しているのでしょうか？

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6InRlc3RAZXhhbXBsZS5jb20iLCJpYXQiOjE1OTkwNjY2MjIsImV4cCI6MTU5OTA2NzUyMiwiYXVkIjoiaHR0cDovL2xvY2FsaG9zdC8iLCJpc3MiOiJodHRwOi8vbG9jYWxob3N0Iiwic3ViIjoiMSIsImp0aSI6IjZmZDFmYjYyLTQ5MmEtNDE3Ni1iY2E2LWVmOGNlN2Q2Njg3MCJ9.jvWDUIpF-Yg-ixrK5Osy2v8ce111I9DiOkKDAnfmBxQ
```

> https://jwt.io/

https://jwt.io/ で JWT を解析することができますので、実際に前述のトークンを解析してみましょう。

![JWTサンプル](./images/jwt.png)

---

解析すると 3 つのブロックになっていることがわかります。

`[header].[payload].[signature]`

つまり、JWT は Base64 デコードすればブロックごとに情報が取得する事ができることとなります。

もう少し詳しく JWT の説明をしたいとおもいます。

---

### header とは

```
{
  "alg": "HS256",
  "typ": "JWT"
}
```

文字通り、`header`はヘッダとなり、`alg`は署名を生成するアルゴリズム  が記載されています。サンプルの場合は`HMAC-SHA256`を使っているという意味になります。

`typ`に関してはトークンの種類を示すフィールドとなりますが、JWT を利用している場合には`JWT`とすることを推奨されています。

### payload とは

```
{
  "email": "test@example.com",
  "iat": 1599066622,
  "exp": 1599067522,
  "aud": "http://localhost/",
  "iss": "http://localhost",
  "sub": "1",
  "jti": "6fd1fb62-492a-4176-bca6-ef8ce7d66870"
}
```

`payload`はまさに認証データなどがあります。これらのフィールドは`claims`と呼ばれています。`claims`には`標準クレーム`と`カスタムクレーム`があります。

サンプルは`email`はカスタムクレームとなり、それ以外は`標準クレーム`となります。  
サンプルではド直球に`email`としていますが本来`payload`にユーザー自体を特定できるような情報は記載することは避けるべきです。
（※ google は使っているがサービスアカウントはメールアカウント形式なので）

前述したように JWT は JSON を Base64 エンコードした文字列のため、サービス側で受けとった JWT をデコードして

`header`と `payload`を判断してレスポンスを返すか判断します。

| コード　 | 名称　          | 説明                                 |
| :------- | :-------------- | :----------------------------------- |
| iss      | Issuer          | トークン発行者の識別子               |
| sub      | Subject         | トークンの主題の識別子               |
| aud      | Audience        | トークンが意図している受信者の識別子 |
| exp      | Expiration Time | トークンの有効期限 ※数値で指定       |
| nbf      | Not Before      | トークンの開始日時 ※数値で指定       |
| iat      | Issued at       | トークンの発行日時                   |
| jti      | JWT ID          | 発行者ごとトークンごとに一意な識別子 |

---

#### Issuer (iss) とは？

Issuer はトークンを発行したサービスのドメインにしていることがほとんどです。  
例の場合は http://localhost としています。

#### Subject (sub) とは？

JWT の用途を示します。 値は大文字/小文字が区別され、同じ Issuer 内でユニークである必要があります。  
(※サンプルではユーザー ID を返却していますが用途と少し乖離しています。 ）

#### Audience (aud) とは？

JWT の想定利用者を意味します。  
サービス自体に role や authority といった権限などのポリシーが存在し、エンドポイントに対してそれらの制限がある場合には使われます。

#### Expiration Time (exp)とは？

JWT が失効する日時です。このクレームは数値となりその日時を過ぎている場合は受け付けてはいけません。

#### Not Before (nbf)とは？

`exp`とは逆で指定の日付以前はそのトークンを受け付けてはいけません。  
※通常は恣意的に指定されることはない。

#### Issued at (iat)とは？

JWT が発行された日付となります

#### JWT ID (jti)とは？

JWT のユニーク性を担保するユニーク値

---

このように標準クレームが存在しますが、すべて optional の値となり JWT としては標準クレームを利用しなくても JWT としては誤りではありません。

しかし、セキュリティを考えた場合には、`iss`, `exp`, `aud`,`sub`などのクレームを利用することが望ましいです。

標準クレームとカスタムクレームと伝えましたが、JWT では 3 種類のクレームが定義されています。

それは`公開クレーム`というものですが、こちらは汎用的に利用しクレームの衝突を回避する為に設けられています。

一般的に使われることはありませんが、カスタムクレームを設計する際に公開クレームと標準クレームに衝突しないフィールドである必要があります。

- Registered Claim Names 　(標準クレーム)
- Public Claim Names (公開クレーム)
- Private Claim Names (カスタムクレーム)

> https://www.iana.org/assignments/jwt/jwt.xhtml

---

### signature とは

ここまでざっくりと、payload と header を説明していましたが`signature`に対して触れていませんでした。

いままでの説明で JSON を base64 エンコードで文字列化しているものが JWT だとわかったとおもいますが、  
Base64 文字列されたものであれば、「JSON を書き換えかえて使えば、本来見れないデータにもアクセスできるのでは？」結論からいうと、それを防ぐのが`signature`となります。

`signature`は `header`と`payload`を base64 エンコードして、それを更にサーバ側が保持している秘密鍵（シークレットキーなど）を使ってハッシュ化しています。
そのため, header や payload を改ざんして JWT になりすましても`signature`が異なる為そのトークンは改ざんされたものと判断することができるという寸法です。

---

最後に、駆け足でかいつまんで説明しました為セキュリティ等は特に触れていません。
たしかに、JWT はデファクトスタンダードではありますが、銀の銃弾やセッションに成り代わるものではない為、色々な記事などを参考にしていただけると幸いです。

一応仕組みをしれば、0 から JWT 発行などを作ることも可能ですが、https://jwt.io/　では各言語の JWT ライブラリもありますのでそちらを利用するようにしましょう。
